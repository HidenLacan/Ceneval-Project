import os
import json
import re
from io import BytesIO
from django.core.mail import EmailMessage
from django.template.loader import render_to_string
from django.conf import settings
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT
import folium
from PIL import Image as PILImage
import base64
import tempfile
from difflib import SequenceMatcher


###### ruta generation to send via email


def get_map_url_from_configuracion(configuracion_ruta, verify_exists=True):
    """
    Extract map ID from mapa_html field and return the corresponding map URL
    Optionally verify if the map exists in the API
    """
    try:
        if not configuracion_ruta.mapa_html:
            print("No hay mapa_html en la configuraci√≥n")
            return None
        
        # Extract map ID from mapa_html
        # Example: <div class="folium-map" id="map_colonia_33" style="width: 100%; height: 400px;"></div>
        import re
        
        # Check if this is a complete HTML document (generated by our function)
        if configuracion_ruta.mapa_html.strip().startswith('<!DOCTYPE html>'):
            colonia_id = configuracion_ruta.colonia.id
            print(f"‚úÖ Usando ID de colonia directamente: {colonia_id}")
            map_id = str(colonia_id)
        else:
            # Look for id="map_colonia_X" pattern in partial HTML
            id_pattern = r'id="map_colonia_(\d+)"'
            match = re.search(id_pattern, configuracion_ruta.mapa_html)
            
            if not match:
                # Try alternative patterns for different HTML formats
                alt_patterns = [
                    r'id="map_(\d+)"',  # id="map_33"
                    r'id="map_(\w+)_(\d+)"',  # id="map_colonia_33"
                    r'id="(\w+)_(\d+)"',  # id="colonia_33"
                ]
                
                for pattern in alt_patterns:
                    match = re.search(pattern, configuracion_ruta.mapa_html)
                    if match:
                        print(f"ID encontrado con patr√≥n alternativo: {pattern}")
                        break
                
                if not match:
                    print(f"No se encontr√≥ ID de mapa en mapa_html")
                    print(f" Contenido de mapa_html: {configuracion_ruta.mapa_html[:200]}...")
                    return None
            
            map_id = match.group(1)
        print(f"ID de mapa extra√≠do: {map_id}")
        
        # Construct the map filename
        map_filename = f"mapa_colonia_{map_id}.html"
        map_url = f"/api/maps/{map_filename}"
        
        # Optionally verify if the map exists
        if verify_exists:
            try:
                import requests
                from django.conf import settings
                
                # Get the list of available maps
                base_url = settings.BASE_URL
                response = requests.get(f"{base_url}/core/api/maps/", timeout=5)
                
                if response.status_code == 200:
                    maps_data = response.json()
                    available_maps = maps_data.get('maps', [])
                    
                    if map_filename in available_maps:
                        print(f"‚úÖ Mapa encontrado en API: {map_filename}")
                    else:
                        print(f"‚ö†Ô∏è Mapa no encontrado en API: {map_filename}")
                        print(f"üìÅ Mapas disponibles: {available_maps}")
                        return None
                else:
                    print(f"‚ö†Ô∏è No se pudo verificar mapas disponibles: {response.status_code}")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Error verificando mapas disponibles: {str(e)}")
                # Continue anyway, maybe the API is not available
        
        print(f"üó∫Ô∏è URL del mapa: {map_url}")
        return map_url
        
    except Exception as e:
        print(f"Error extrayendo URL del mapa: {str(e)}")
        return None


def send_route_email(configuracion_ruta, empleados_info):
    """
    Send route information via email to assigned employees
    """
    try:
        url_map = get_map_url_from_configuracion(configuracion_ruta, verify_exists=False)
        subject = f"üó∫Ô∏è Rutas Asignadas - {configuracion_ruta.colonia.nombre}"
        
        context = {
            'configuracion_ruta': configuracion_ruta,
            'empleados_info': empleados_info,
            'colonia_nombre': configuracion_ruta.colonia.nombre,
            'map_url': url_map
        }
        
        html_message = render_to_string('email_route_assignment.html', context)
        
        # Create plain text message with map URL
        plain_message = f"""
        Rutas Asignadas - {configuracion_ruta.colonia.nombre}
        
        Hola,
        
        Se han asignado rutas para la colonia {configuracion_ruta.colonia.nombre}.
        
        """
        if url_map:
            plain_message += f"""
        üó∫Ô∏è Mapa de la colonia: {settings.BASE_URL}{url_map}
        
        """
        else:
            plain_message += """
         Mapa no disponible
        
        """
        plain_message += """
        Empleados asignados:
        """
        
        for empleado in empleados_info:
            plain_message += f"- {empleado['nombre']} ({empleado['email']})\n"
        
        plain_message += f"""
        
        Fecha de configuraci√≥n: {configuracion_ruta.fecha_creacion.strftime('%d/%m/%Y %H:%M')}
        Configurado por: {configuracion_ruta.creado_por.username}
        """
        
        # Check if we're in development mode (no real email configuration)
        if settings.DEBUG or settings.DEFAULT_FROM_EMAIL == 'your-email@gmail.com':
            # In development, just log the email would be sent
            print(f"üìß [DEV MODE] Email would be sent to:")
            for empleado in empleados_info:
                print(f"   - {empleado['nombre']} ({empleado['email']})")
            print(f"   Subject: {subject}")
            
            return True, f"Emails simulados enviados exitosamente a {len(empleados_info)} empleado(s) (modo desarrollo)"
        
        # Send email to each employee (production mode)
        for empleado in empleados_info:
            email = EmailMessage(
                subject=subject,
                body=plain_message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                to=[empleado['email']],
                reply_to=[settings.DEFAULT_FROM_EMAIL]
            )
            
            email.send()
        
        return True, f"Emails enviados exitosamente a {len(empleados_info)} empleado(s)"
        
    except Exception as e:
        return False, f"Error al enviar emails: {str(e)}"


def send_route_email_from_staff_dashboard(colonia_id, employee_ids):
    """
    Send route information from staff dashboard
    """
    try:
        from core.models import ColoniaProcesada, ConfiguracionRuta
        from django.contrib.auth import get_user_model
        User = get_user_model()
        
        # Get colonia
        colonia = ColoniaProcesada.objects.get(id=colonia_id)
        
        # Get employees
        empleados = User.objects.filter(id__in=employee_ids, role='employee')
        
        if not empleados.exists():
            return False, "No se encontraron empleados v√°lidos"
        
        # Get or create configuration
        configuracion_ruta, created = ConfiguracionRuta.objects.get_or_create(
            colonia=colonia,
            creado_por=User.objects.filter(role='staff').first(),
            defaults={
                'mapa_calculado': {},
                'tiempo_calculado': None,  # Cambiado de string a None
                'estado': 'pendiente'
            }
        )
        
        # Prepare employee info
        empleados_info = []
        for empleado in empleados:
            empleados_info.append({
                'id': empleado.id,
                'nombre': empleado.username,
                'email': empleado.email
            })
        
        # Send emails
        success, message = send_route_email(configuracion_ruta, empleados_info)
        
        return success, message
        
    except ColoniaProcesada.DoesNotExist:
        return False, "Colonia no encontrada"
    except Exception as e:
        return False, f"Error: {str(e)}" 

##############################################

def normalize_colonia_name(nombre):
    """
    Normaliza el nombre de una colonia para b√∫squedas consistentes.
    """
    if not nombre:
        return ""
    
    # Convertir a min√∫sculas
    nombre = nombre.lower().strip()
    
    # Remover caracteres especiales y acentos
    nombre = re.sub(r'[√°√†√§√¢]', 'a', nombre)
    nombre = re.sub(r'[√©√®√´√™]', 'e', nombre)
    nombre = re.sub(r'[√≠√¨√Ø√Æ]', 'i', nombre)
    nombre = re.sub(r'[√≥√≤√∂√¥]', 'o', nombre)
    nombre = re.sub(r'[√∫√π√º√ª]', 'u', nombre)
    nombre = re.sub(r'[√±]', 'n', nombre)
    
    # Remover caracteres especiales excepto espacios y guiones
    nombre = re.sub(r'[^a-z0-9\s\-]', '', nombre)
    
    # Normalizar espacios m√∫ltiples
    nombre = re.sub(r'\s+', ' ', nombre)
    
    return nombre.strip()

def validate_colonia_name(nombre):
    """
    Valida si el nombre de una colonia es v√°lido.
    """
    if not nombre or len(nombre.strip()) < 3:
        return False, "El nombre debe tener al menos 3 caracteres"
    
    if len(nombre.strip()) > 100:
        return False, "El nombre es demasiado largo"
    
    # Verificar que contenga al menos una letra
    if not re.search(r'[a-zA-Z]', nombre):
        return False, "El nombre debe contener al menos una letra"
    
    return True, "Nombre v√°lido"

def calculate_similarity_score(str1, str2):
    """
    Calcula la similitud entre dos strings usando SequenceMatcher.
    """
    return SequenceMatcher(None, str1.lower(), str2.lower()).ratio()

def suggest_colonia_names(query, existing_colonias, max_suggestions=5):
    """
    Sugiere nombres de colonias bas√°ndose en la query y colonias existentes.
    """
    if not query or len(query.strip()) < 2:
        return []
    
    query_normalized = normalize_colonia_name(query)
    suggestions = []
    
    for colonia in existing_colonias:
        colonia_normalized = normalize_colonia_name(colonia)
        
        # Calcular similitud
        similarity = calculate_similarity_score(query_normalized, colonia_normalized)
        
        # Si la similitud es mayor a 0.3, agregar a sugerencias
        if similarity > 0.3:
            suggestions.append({
                'nombre': colonia,
                'similarity': similarity
            })
    
    # Ordenar por similitud y tomar los mejores
    suggestions.sort(key=lambda x: x['similarity'], reverse=True)
    return [s['nombre'] for s in suggestions[:max_suggestions]]

def clean_colonia_input(input_text):
    """
    Limpia y normaliza el input del usuario para b√∫squeda de colonias.
    """
    if not input_text:
        return ""
    
    # Remover espacios extra al inicio y final
    cleaned = input_text.strip()
    
    # Remover caracteres problem√°ticos comunes
    cleaned = re.sub(r'[^\w\s\-√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë]', '', cleaned)
    
    # Normalizar espacios m√∫ltiples
    cleaned = re.sub(r'\s+', ' ', cleaned)
    
    return cleaned

def extract_location_info(nombre):
    """
    Extrae informaci√≥n de ubicaci√≥n del nombre de la colonia.
    """
    info = {
        'colonia': nombre,
        'ciudad': None,
        'estado': None,
        'pais': 'M√©xico'
    }
    
    # Patrones comunes para extraer informaci√≥n
    patterns = {
        'ciudad': r'(?:en|de)\s+([A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±\s]+?)(?:\s*,|\s*$)',
        'estado': r'(?:,\s*|en\s+)([A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±\s]+?)(?:\s*,|\s*$)'
    }
    
    for key, pattern in patterns.items():
        match = re.search(pattern, nombre, re.IGNORECASE)
        if match:
            info[key] = match.group(1).strip()
    
    return info

def format_colonia_display_name(nombre, info=None):
    """
    Formatea el nombre de la colonia para mostrar.
    """
    if not info:
        info = extract_location_info(nombre)
    
    display_parts = [nombre]
    
    if info.get('ciudad'):
        display_parts.append(f"({info['ciudad']})")
    
    return " ".join(display_parts)

def get_colonia_search_variations(nombre):
    """
    Genera variaciones de b√∫squeda para un nombre de colonia.
    """
    variations = [nombre]
    
    # Variaci√≥n sin acentos
    sin_acentos = re.sub(r'[√°√†√§√¢]', 'a', nombre.lower())
    sin_acentos = re.sub(r'[√©√®√´√™]', 'e', sin_acentos)
    sin_acentos = re.sub(r'[√≠√¨√Ø√Æ]', 'i', sin_acentos)
    sin_acentos = re.sub(r'[√≥√≤√∂√¥]', 'o', sin_acentos)
    sin_acentos = re.sub(r'[√∫√π√º√ª]', 'u', sin_acentos)
    sin_acentos = re.sub(r'[√±]', 'n', sin_acentos)
    variations.append(sin_acentos)
    
    # Variaci√≥n con "Colonia" al inicio
    if not nombre.lower().startswith('colonia'):
        variations.append(f"Colonia {nombre}")
    
    # Variaci√≥n sin "Colonia" al inicio
    if nombre.lower().startswith('colonia'):
        variations.append(nombre.replace('Colonia ', '').replace('colonia ', ''))
    
    return list(set(variations))  # Remover duplicados 